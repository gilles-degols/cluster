package net.degols.libs.cluster.core

import akka.actor.ActorRef
import net.degols.libs.cluster.messages.WorkerTypeInfo
import net.degols.libs.election.Tools
import org.joda.time.DateTime

import scala.util.Random

/**
  * One instance of a WorkerType. Their number can grow up to any number, it will depend on the load of the system.
  * The WorkerId is a unique string generated by the master to easily handle "waiting" instances of WorkerTypes to be started
  */
class Worker(val workerId: String, val actorRef: Option[ActorRef]) extends ClusterElement{
  private var _lastPing: DateTime = new DateTime()

  def canEqual(a: Any): Boolean = a.isInstanceOf[Worker]
  override def equals(that: Any): Boolean =
    that match {
      case that: Worker => that.canEqual(this) && this.hashCode == that.hashCode
      case _ => false
    }
  override def hashCode: Int = s"Worker:$workerId".hashCode // We use the workerId to compare object, without the actorRef!
}


object Worker {
  def fromWorkerIdAndActorRef(workerId: String, actorRef: Option[ActorRef]): Worker = {
    val worker = new Worker(workerId, actorRef)
    worker
  }

  var workerNumber: Long = 0L
  val rand = Random

  def generateWorkerId(workerTypeInfo: WorkerTypeInfo): String = {
    // Some random just in case
    val salt = rand.nextInt(1000)

    // This is not a major problem if there is a concurrent access, just prettier to have incremental number
    synchronized {
      workerNumber += 1
      s"${workerTypeInfo.workerTypeId}-$workerNumber-$salt"
    }
  }
}